Решение Задачи. Назовём части шаблона между вопросами паттернами. Поместим Каждый из них в бор с флагом, равным индексу последнего паттерна в 
шаблоне. Таким образом, у одной терминальной вершины в боре может оказаться несколько флагов, соответствующих одинаковым по содержанию, но не по 
положению шаблонам. Теперь, в соответствии с алгоритмом Ахо-Корасик, находим в каждом префиксе текста все паттерны, являющиеся его суффиксами. 
Каждый паттерн обрабатываем. Обработка: если мы находимся в тексте на позиции i, a паттерн имеет флаг j, то это значит, что паттерн не против, 
тобы шаблон в тексте начинался с j – i –го символа, потому что тогда данный паттерн окажется на своем месте. В специальном массиве voting 
тмечаем, что данный паттерн «голосует» за j-i-ый индекс. Если все паттерны проголосуют за некоторый индекс, значит шаблон может начинаться с него
ксте(если конечно шаблон не вылезет за пределы текста за счет вопросиков в конце – этот случай тоже надо не забыть об работать). То есть 
пробегаемся по voting и добавляем в ответ индексы, значение которых равно количеству паттернов в шаблоне.
Ахо-Корасик. Есть бор - это класс. Он хранит вектор вершин и методы 1) go – его задача пройти по символу текста из данной вершины. Сначала он 
пытается пройти вперед по символу, если терпит неудачу, то находит наибольший суффикс данной подстроки(подстроки, которую задает данная вершина), 
содержащийся в боре и возвращает go от него. Таким образом  go позволяет оказаться в вершине бора, задающей максимальный суффикс нового префикса 
текста из всех, имеющихся в боре. Результат go из вершины запоминается, чтобы его потом повторно не считать.
2) suflink  - его задача найти наибольший суффикс данной подстроки, содержащийся в боре. Он равен наибольшему суффиксу предыдущего префикса 
текста, из которого в боре есть путь по символу в данный префикс. Другими словами suflink(x) = go(suflink(prev(x))). Результат suflink из вершины
запоминается, чтобы его потом повторно не считать
3) way – его задачата же, что и у suflink, только находить терминальные суффиксы. То есть он не останавливается в нетерминальных суффиксах, а 
продолжает поиск, пока не найдет терминальный или корень.
Задача: найти все вхождения строк в текст. Решение: добавляем строки в бор. Идем по тексту. Для каждого нового символа проводим обработку. 
Необходимо найти все строки, которые заканчиваются на данный символ. То есть необходимо проверить на терминальность все суффиксы данного префикса,
которые есть в тексте. Это делается по way.  Далее совершаем go по следующему символу и попадаем в наибольший суффикс нового префикса текста из 
лежащих в боре. Теперь все суффиксы нового префикса из бора – также суффиксы его наибольшего суффикса. Их снова можно перебирать по way и 
отмечать вхождения строк в текст.
Ассимптотика: пусть n – размер текста, m – кол-во вершин бора. Тогда мы делаем в алгоритме n переходов go к новому символу. 
